## 一. 数据类型介绍

C语⾔提供了丰富的数据类型来描述⽣活中的各种数据。

使⽤整型类型来描述整数，使⽤字符类型来描述字符，使⽤浮点型类型来描述⼩数。

所谓“类型”，就是相似的数据所拥有的共同特征，编译器只有知道了数据的类型，才知道怎么操作数据。

下⾯盘点⼀下C语⾔提供的各种数据类型，本章节主要探讨内置数据类型。

![image-20240120224244968](assets/image-20240120224244968.png)

### 01. 字符型

```c
char // character
[signed] char // 有符号的
unsigned char // 无符号的
```

### 02. 整型

```c
// 短整型
short [int]
[signed] short [int]
unsigned short [int]
  
// 整型
int
[signed] int
unsigned int

// 长整型
long [int]
[signed] long [int]
unsigned long [int]

// 更长的整型
// C99中引入
long long [int]
[signed] long long [int]
unsigned long long [int]
```

### 03. 浮点型

```c
float // 单精度浮点型 12.34 => 1.234 * 10
double // 双精度浮点型 能表示更精准的数字
long double
```

### 04. 布尔类型

`bool` 和 `_Bool` 是 C 语言中用于表示布尔类型的关键字。

1. **bool：** 自C99标准起，C语言引入了 <stdbool.h> 头文件，并定义了 bool、true 和 false 三个关键字。bool 是一种数据类型，可以取 true 或 false 的值。例如：

   ```c
   #include <stdbool.h>
   
   int main() {
     bool myBool = true;
     printf("%d\n", myBool);  // 输出 1，true在C中通常用1表示
     return 0;
   }
   ```

2. **_Bool：** 在较早版本的C标准中，使用了 _Bool 来表示布尔类型。然而，_Bool 不包含 <stdbool.h> 头文件中定义的 true 和 false 关键字，而是使用 `0` 表示 `false`，非零值表示 `true`。例如：

   ```c
   cCopy codeint main() {
       _Bool myBool = 1;  // 1 表示 true
       printf("%d\n", myBool);  // 输出 1
       return 0;
   }
   ```

总体而言，`bool` 是更加现代且直观的表示方式，而 `_Bool` 是较早版本C标准中的一种表示方式。在新代码中，建议使用 `bool`。

### 05. 各种数据类型的⻓度

每⼀种数据类型都有⾃⼰的⻓度，使⽤不同的数据类型，能够创建出⻓度不同的变量，变量⻓度的不同，存储的数据范围就有所差异。

- sizeof 操作符

  - sizeof 是⼀个关键字，也是操作符，专⻔是⽤来计算sizeof的操作符数的类型⻓度的，**单位是字节**。

  - sizeof 操作符的操作数可以是类型，也可是变量或者表达式。

    ```c
    sizeof(类型)
    sizeof 表达式
    ```

  - sizeof 的操作数如果不是类型，是表达式的时候，可以省略掉后边的括号的。
  - sizeof 后边的表达式是不真实参与运算的，根据表达式的类型来得出⼤⼩。
  - sizeof 的计算结果是 size_t 类型的。

  > sizeof 运算符的返回值，C 语⾔只规定是⽆符号整数，并没有规定具体的类型，⽽是留给系统⾃⼰去决定， sizeof 到底返回什么类型。不同的系统中，返回值的类型有可能是unsigned int ，也有可能是 unsigned long ，甚⾄是 unsigned long long ，对应的 printf() 占位符分别是 %u 、 %lu 和 %llu 。这样不利于程序的可移植性。
  >
  > C 语⾔提供了⼀个解决⽅法，创造了⼀个类型别名 size_t ，⽤来统⼀表⽰ sizeof 的返回值类型。对应当前系统的 sizeof 的返回值类型，可能是 unsigned int ，也可能是unsigned long long 

- 比如：

  ```c
  #include <stdio.h>
  int main()
  {
  	int a = 10;
  	printf("%zd\n", sizeof(a)); // 4
  	printf("%zd\n", sizeof a); // 4，表达式写法
  	printf("%zd\n", sizeof(int)); // 4 类型必须带()
  	printf("%zd\n", sizeof(3 + 3.5)); // 8
  	return 0;
  }
  ```

- 数据类型长度（在VS2022 X64配置下的输出）

  ```c
  #include <stdio.h>
  int main() {
  	printf("%d\n", sizeof(char)); // 1
  	printf("%d\n", sizeof(short)); // 2
  	printf("%d\n", sizeof(int)); // 4
  	printf("%d\n", sizeof(long)); // 4
    // 为什么long跟int都是4，不应该long>int吗
    // C语言标准规定：sizeof(long) >= sizeof(int)，根据不同编译器厂商实现结果不同
  	printf("%d\n", sizeof(long long)); // 8
  	printf("%d\n", sizeof(float)); // 4
  	printf("%d\n", sizeof(long double)); // 8
  	printf("%d\n", sizeof(bool)); // 1
  
  	return 0;
  }
  ```

- sizeof 中表达式不计算

  ```c
  int main()
  {
  	short s = 3;
  	int b = 10;
  	printf("%d\n", sizeof(s = b + 1)); // 2
  	printf("s = %d\n", s); // s = 3
  	return 0;
  }
  ```

  sizeof 在代码进⾏编译的时候，就根据表达式的类型确定了，⽽表达式的执⾏却要在程序运⾏期间才能执⾏，在编译期间已经将sizeof处理掉了，所以在运⾏期间就不会执⾏表达式了。

  在 C 语言中，赋值表达式的结果是被赋值的左值的类型。在这个情况下，赋值表达式 `s = b + 1` 的结果是 `short` 类型，因为 `s` 是 `short` 类型。

  然而，`sizeof` 运算符在求值的时候不会实际执行赋值操作，它只是根据类型返回大小。所以，`sizeof(s = b + 1)` 的结果是 `sizeof(short)`。

  现在，关于 `sizeof(short)` 的结果，`short` 类型通常占用2个字节（16位）。因此，`sizeof(s = b + 1)` 的输出是2。