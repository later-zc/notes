## 一. 操作符的分类

- 算术操作符： `+`、`-`、`*`、`/`、`%`
- 移位操作符：`<< >>`
- 位操作符：`&` 、`|` 、`^`
- 赋值操作符：`=`、`+=`、`-=`、`=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`|= `、`^=*`
- *单⽬操作符： `!`、`++`、`--`、`&`、`*`、`+`、`-`、`~` 、`sizeof`、(类型)
- 关系操作符: `>`、`>=`、`< `、`<=`、`==`、`!=`
- 逻辑操作符： `&&`、`||`
- 条件操作符： `? `、`:`
- 逗号表达式：`,`
- 下标引⽤： `[]`
- 函数调⽤： `()`
- 结构成员访问： `.` 、`->`

上述的操作符，前面部分已经讲过算术操作符、赋值操作符、逻辑操作符、条件操作符和部分的单⽬操作符，这里继续介绍⼀部分，操作符中有⼀些操作符和⼆进制有关系，我们先铺垫⼀下⼆进制的和进制转换的知识。

## 二. 二进制和进制转换

其实我们经常能听到 2进制、8进制、10进制、16进制 这样的讲法，那是什么意思呢？其实2进制、8进制、10进制、16进制是数值的不同表⽰形式⽽已。

⽐如：数值15的各种进制的表⽰形式：

```c
15的2进制：1111
15的8进制：17
15的10进制：15
15的16进制：F
// 16进制的数值之前写：0x
// 8进制的数值之前写:0
```

我们重点介绍⼀下⼆进制：

⾸先我们还是得从10进制讲起，其实10进制是我们⽣活中经常使⽤的，我们已经形成了很多尝试：

- 10进制中满10进1
- 10进制的数字每⼀位都是0~9的数字组成

其实⼆进制也是⼀样的

- 2进制中满2进1
- 2进制的数字每⼀位都是0~1的数字组成

那么 1101 就是⼆进制的数字了。

### 01. 2进制转10进制

其实10进制的123表⽰的值是⼀百⼆⼗三，为什么是这个值呢？其实10进制的每⼀位是有权重的，10进制的数字从右向左是个位、⼗位、百位....，分别每⼀位的权重是10^0、10^1、10^2... 

如下图：

<img src="assets/image-20240408221916677.png" alt="image-20240408221916677" style="zoom:80%;" />

2进制和10进制是类似的，只不过2进制的每⼀位的权重，从右向左是：2^0、2^1、2^2 ... 

如果是2进制的1101，该怎么理解呢？

<img src="assets/image-20240408222054491.png" alt="image-20240408222054491" style="zoom:80%;" />

### 02. 10进制转2进制数字

<img src="assets/image-20240408222203109.png" alt="image-20240408222203109" style="zoom:80%;" />

### 03. 2进制转8进制

8进制的数字每⼀位是0~7的，0~7的数字，各⾃写成2进制，最多有3个2进制位就⾜够了，⽐如7的⼆进制是111，所以在2进制转8进制数的时候，从2进制序列中右边低位开始向左每3个2进制位会换算⼀个8进制位，剩余不够3个2进制位的直接换算。

如：2进制的 01101011，换成8进制：0153，**0开头的数字，会被当做8进制**。

<img src="assets/image-20240408223724818.png" alt="image-20240408223724818" style="zoom:80%;" />

### 04. 2进制转16进制

16进制的数字每⼀位是0~9,a ~f 的，0~9,a ~f的数字，各⾃写成2进制，最多有4个2进制位就⾜够了，⽐如 f 的⼆进制是1111，所以在2进制转16进制数的时候，从2进制序列中右边低位开始向左每4个2进制位会换算⼀个16进制位，剩余不够4个⼆进制位的直接换算。

如：2进制的01101011，换成16进制：0x6b，**16进制表示的时候前⾯加0x**

<img src="assets/image-20240408223842310.png" alt="image-20240408223842310" style="zoom:80%;" />



## 三. 原码、反码、补码

整数的2进制表示方法有三种：原码、反码和补码。

换句话说：**原码、反码和补码**指的是**整数的2进制表示方式**。

有符号整数的三种表⽰⽅法均有符号位和数值位两部分。

2进制序列中，**最⾼位的1位**是被当做**符号位**，**剩余**的都是**数值位**。

**无符号数，没有符号位，等价为正数，无法表示负数。**

```c
unsigned int num1 = 100;
unsigned int num2 = -100;
// 无符号数的打印格式，会存在问题
printf("%u\n", num1); // 100
printf("%u\n", num2); // 4294967196

// %d的打印格式，会把值当成有符号数打印
printf("%d\n", num1); // 100
printf("%d\n", num2); // -100
```

**符号位**都是⽤**0表⽰“正”**，⽤**1表⽰“负”**。

```c
// a是整型类型的，a是占4个字节位的（32bit）
// 32bit的内存存储空间中，数值10的二进制为：0000 0000 0000 0000 0000 0000 0000 1010
int a = 10; // 等价于 signed int a = 10;

// b也是整型类型的，占4个字节位
// 32bit的内存存储空间中，数值-10的二进制为：1000 0000 0000 0000 0000 0000 0000 1010
int b = -10; // 等价于 signed int b = -10;
```

> **1个bit指的是二进制中的一位，是信息的最小单位。**
>
> **1个字节表示8个bit位，储存的数值范围为0-255。**

1. **正整数的原、反、补码都相同**。

   ```c
   // 示例：
   int a = 10;
   // 正整数a的值的原码、反码和补码都相同，即：
   // 0000 0000 0000 0000 0000 0000 0000 1010
   ```

2. **负整数**的原、反、补码表⽰⽅法**各不相同**。

   ```c
   // 示例：
   int b = -10;
   
   // 负整数的原码：
   // 直接将数值按照正负数的形式翻译成⼆进制得到的就是原码。
   // 1000 0000 0000 0000 0000 0000 0000 1010
   
   // 负整数的反码：
   // 将原码的符号位不变，其他位依次按位取反就可以得到反码。
   // 1111 1111 1111 1111 1111 1111 1111 0101
   
   // 负整数的补码：
   // 反码+1就得到补码。
   // 1111 1111 1111 1111 1111 1111 1111 0110
   ```

   - 负整数的补码 =>原码有两种方式：
     1. 可以先-1得到反码，再取反得到原码
     2. 先取反，再+1直接得到原码

> - **整数在内存中存放的是补码**。为什么呢？
>
>   - 在计算机系统中，数值⼀律⽤补码来表⽰和存储。原因在于，使⽤补码，可以将符号位和数值位统⼀处理；同时，加法和减法也可以统⼀处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
>
>     ```c
>     int a = 1 - 1; // 1 + (-1)
>     // 1. 如果用原码计算，存在问题
>     // 0000 0000 0000 0000 0000 00000 0000 0001：1的原码
>     // 1000 0000 0000 0000 0000 00000 0000 0001：-1的原码
>     // 如果使用原码相加，结果如下；
>     // 1000 0000 0000 0000 0000 00000 0000 0010：-2？？？错的
>     
>     // 使用补码计算就正确了
>     // 0000 0000 0000 0000 0000 00000 0000 0001：1的补码
>     // 1111 1111 1111 1111 1111 1111 1111 1111：-1的补码
>     // 如果使用补码相加，结果如下；
>     // 1 0000 0000 0000 0000 0000 00000 0000 0000：进1，最终第33位上得1
>     // 根据结果得知：变成33位了，而int a 是4个字节，为32位，必然就存不下了
>     // 存不下了，多出的第33位就会被截断，最终存储的结果为：
>     // 0000 0000 0000 0000 0000 00000 0000 0000：0（结果正确）
>     
>     // 所以根据示例得出为什么整数在内存中存放使用的是补码，而不是原码了。
>     ```







## 四. 移位操作符

## 五. 位操作符：&、|、^、~

## 六. 单目操作符

## 七. 逗号表达式

## 八. 下标访问[]、函数调用()

## 九. 结构成员访问操作符

## 十. 操作符的属性：优先级、结合性

## 十一. 表达式求值

