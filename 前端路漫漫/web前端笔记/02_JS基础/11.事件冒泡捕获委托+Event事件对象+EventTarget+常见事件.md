# 一. 认识事件处理

---

## 1. 认识事件（Event）

- Web页面需要经常和用户之间进行交互，而交互的过程中我们可能想要捕捉这个交互的过程：

  - 比如用户点击了某个按钮、用户在输入框里面输入了某个文本、用户鼠标经过了某个位置
  - 浏览器需要搭建一条JavaScript代码和事件之间的桥梁
  - 当某个事件发生时，让JavaScript可以相应（执行某个函数），所以我们需要针对事件编写处理程序（handler）

- 如何进行事件监听呢？

  - 事件监听方式一：直接在html中编写JavaScript代码

    ```html
    <div id='box' onclick='alert("box点击")'></div>
    ```

  -  事件监听方式二：DOM属性，通过元素的on来监听事件

    ```js
    box.onclick = function() {
        alert('box点击')
    }
    ```

  - 事件监听方式三：通过EventTarget中的addEventListener来监听

    - 
    
    ```js
    box.addEventListener('click', function() {
        alert('box点击')
    })
    ```

## 2. 常见的事件列表

- 鼠标事件：
  - click —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）
  - mouseover / mouseout —— 当鼠标指针移入/离开一个元素时
  - mousedown / mouseup —— 当在元素上按下/释放鼠标按钮时
  - mousemove —— 当鼠标移动时
- 键盘事件：
  - keydown 和 keyup —— 当按下和松开一个按键时
- 表单（form）元素事件：
  - submit —— 当访问者提交了一个 <form> 时
  - focus —— 当访问者聚焦于一个元素时，例如聚焦于一个 <input>
- Document 事件：
  - DOMContentLoaded —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时
- CSS 事件：
  - transitionend —— 当一个 CSS 动画完成时

# 二. 事件冒泡捕获

---

## 1. 认识事件流

- 事实上对于事件有一个概念叫做事件流，为什么会产生事件流呢？

  - 我们可以想到一个问题：当我们在浏览器上对着一个元素点击时，你点击的不仅仅是这个元素本身
  - 这是因为我们的HTML元素是存在父子元素叠加层级的
  - 比如一个span元素是放在div元素上的，div元素是放在body元素上的，body元素是放在html元素上的

  ![image-20220523222023289](C:\Users\23634\AppData\Roaming\Typora\typora-user-images\image-20220523222023289.png)

## 2. 事件冒泡和事件捕获

- 我们会发现默认情况下事件是**从最内层的span向外依次传递的顺序**，这个顺序我们称之为**事件冒泡（Event Bubble）**

- 事实上，还有另外一种监听事件流的方式就是**从外层到内层（body -> span），**这种称之为**事件捕获（Event Capture）**

- 为什么会产生两种不同的处理流呢？

  - 这是因为早期浏览器开发时，不管是IE还是Netscape公司都发现了这个问题
  - 但是他们采用了完全相反的事件流来对事件进行了传递
  -  IE采用了事件冒泡的方式，Netscape采用了事件捕获的方式

  ![image-20220523222240779](C:\Users\23634\AppData\Roaming\Typora\typora-user-images\image-20220523222240779.png)

## 3. 事件捕获和冒泡的过程

- 如果我们都监听，那么会按照如下顺序来执行：

  ![image-20220523222652312](C:\Users\23634\AppData\Roaming\Typora\typora-user-images\image-20220523222652312.png)

- 1 -> 捕获阶段（Capturing phase）：事件对象从Window传播到目标元素的过程

- 2 -> 目标阶段（Target phase）：事件对象到达目标元素

- 3 -> 冒泡阶段（Bubbling phase）：事件对象从目标元素上开始往上冒泡，直至window

- **`addEventListener`默认`false`处于冒泡阶段，为`true`时，处于捕获阶段**

- 事实上，我们可以通过event对象来获取当前的阶段：eventPhase

- 开发中通常会使用事件冒泡，所以事件捕获了解即可

# 三. 事件对象Event

---

## 1. Event对象

- **当一个事件发生时，就会有和这个事件相关的很多信息**：

  - 比如事件的类型是什么，你点击的是哪一个元素，点击的位置是哪里等等相关的信息
  - 那么这些信息会被**封装到一个Event对象中**，这个对象由浏览器创建，称之为event对象
  - 该对象给我们提供了想要的一些属性，以及可以通过该对象进行某些操作

- **如何获取这个event对象呢？**

  - event对象会在传入的事件处理（event handler）函数回调时，被系统传入

  - 我们可以在回调函数中拿到这个event对象

    ```js
        spanEl.onclick = function(event) {
            console.log('事件对象：', evnet)
        }
    ```

## 2. event常见的属性和方法

- 常见的属性：
  - type：事件的类型
  - target：当前事件触发的元素
  - currentTarget：当前处理事件的元素
  - eventPhase：事件所处的阶段
  - offsetX、offsetY：事件发生在元素内的位置
  - clientX、clientY：事件发生在客户端内的位置
  - pageX、pageY：事件发生在页面中的位置
  - screenX、screenY：事件发生在屏幕的位置
- 常见的方法：
  - **`preventDefault`：取消事件的默认行为**
  - **`stopPropagation`：阻止事件的进一步传递**（冒泡或捕获都可以阻止）

## 3. 事件处理中的this

- 在函数中，我们也可以通过`this`来获取当前的发生元素：

  ```js
      boxEl.addEventListener('click', function(event) {
          console.log(event.target === this) // true
      })
  ```

- 这是因为**在浏览器内部，调用`event handler`是绑定到当前的`target`上的**

# 四. EventTarget使用

---

- 我们会发现，**所有的节点、元素都继承自EventTarget**
  - 事实上**Window也继承自EventTarget**
- 那么这个EventTarget是什么呢？
  - EventTarget是一个**DOM接口**，主要**用于添加、删除、派发Event事件**
- EventTarget常见的方法：
  - addEventListener：注册某个事件类型以及事件处理函数
  - removeEventListener：移除某个事件类型以及事件处理函数
  - dispatchEvent：派发某个事件类型到EventTarget上

```js
    var boxEl = document.querySelector('.box')
    boxEl.addEventListener('click', function() {
        console.log('box发生了点击')
        window.dispatchEvent(new Event('later'))
    })
    boxEl.addEventListener('later', function() {
        console.log('触发了later事件')
    })
```

# 五. 事件委托模式

---

## 1. 事件委托（event delegation）

- 事件冒泡在某种情况下可以帮助我们实现强大的事件处理模式 – **事件委托模式**（也是**一种设计模式**）

- 那么这个模式是怎么样的呢？

  - 因为**当子元素被点击时**，**父元素可以通过冒泡可以监听到子元素的点击**
  - 并且可以**通过event.target获取到触发事件的元素**

- 案例：一个ul中存放多个li，点击某一个li会变成红色

  - 方案一：监听每一个li的点击，并且做出相应处理
  - 方案二：在ul中监听点击，并且通过event.target拿到对应的li进行处理
    - 因为这种方案并不需要遍历后给每一个li上添加事件监听，所以它更加高效

  ```js
  var listEl = document.querySeletor('.list')
  var currentActive = null
  listEl.addEventListener('click', function(event) {
      if (currentActive) currentActive.classList.remove('active')
      event.target.classList.add('active')
      currentActive = event.target
  })
  ```

## 2. 事件委托的标记

- 某些事件委托可能需要对具体的子组件进行区分，这个时候我们可以使用data-*对其进行标记：

- 比如多个按钮的点击，区分点击了哪一个按钮：

  ![image-20220523225810761](C:\Users\23634\AppData\Roaming\Typora\typora-user-images\image-20220523225810761.png)

# 六. 常见的事件

---

## 1. 常见的鼠标事件

- 接下来我们来看一下常见的鼠标事件（不仅仅是鼠标设备，也包括模拟鼠标的设备，比如手机、平板电脑）

- 常见的鼠标事件：

  ![image-20220524121746409](C:\Users\23634\AppData\Roaming\Typora\typora-user-images\image-20220524121746409.png)

## 2. mouseover和mouseenter的区别

- mouseenter和mouseleave
  - **不支持冒泡**
  - 进入子元素依然属于在该元素内，没有任何反应
- mouseover和mosueout
  - **支持冒泡**
  - 进入元素的子元素时
    - 先调用父元素的mouseout
    - 再调用子元素的mouseover
    - 因为支持冒泡，所以会将子元素的mouseover传递到父元素中

![image-20220524122034668](C:\Users\23634\AppData\Roaming\Typora\typora-user-images\image-20220524122034668.png)

## 3. 常见的键盘事件

- 常见的键盘事件：

![image-20220524122102724](C:\Users\23634\AppData\Roaming\Typora\typora-user-images\image-20220524122102724.png)

- 事件的执行顺序是 onkeydown、onkeypress、onkeyup
  - down事件先发生
  -  press发生在文本被输入
  - up发生在文本输入完成
- 我们可以通过key和code来区分按下的键：
  - code：“按键代码”（"KeyA"，"ArrowLeft" 等），特定于键盘上按键的物理位置
  - key：字符（"A"，"a" 等），对于非字符（non-character）的按键，通常具有与 code 相同的值）

## 4. 常见的表单事件

- 针对表单也有常见的事件：

  <img src="C:\Users\23634\AppData\Roaming\Typora\typora-user-images\image-20220524122515099.png" alt="image-20220524122515099" style="zoom:80%;" />

## 5. 文档加载事件

- **DOMContentLoaded**：浏览器**已完全加载 HTML，并构建了 DOM 树**，但像`img`和`css`样式表之类的外部资源可能尚未加载完成

- load：浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等

  ![image-20220524122840906](C:\Users\23634\AppData\Roaming\Typora\typora-user-images\image-20220524122840906.png)

- 事件类型：https://developer.mozilla.org/zh-CN/docs/Web/Events
