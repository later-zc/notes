# 一. this的绑定规则

---

## 1. this到底指向什么呢？

- 我们先来看一个让人困惑的问题：

  - 定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果

  ```js
      function foo() { console.log(this) }
  
      // 调用方式一：直接调用
      foo() // window
  
      // 调用方式二：将foo放到一个对象属性中，通过对象属性引用去调用
      var obj = {
          name: 'later',
          foo: foo
      }
      obj.foo() // obj对象
  
      // 调用方式三：通过call/apply调用
      foo.call('abc') // String {'abc'}对象
  ```

- 这个的案例可以给我们什么样的启示呢？

  - 1.**函数在调用时，`js`会默认给`this`绑定一个值**
  - 2.`this`的绑定和定义的位置（编写的位置）没有关系
  - 3.**this的绑定和调用方式以及调用的位置有关系**
  - 4.**this是在运行时被绑定的**
  
- 那么this到底是怎么样的绑定规则呢？一起来学习一下吧

  - 绑定一：**默认**绑定
  - 绑定二：**隐式**绑定
  - 绑定三：**显示**绑定
  - 绑定四：**new**绑定


## 2. 规则一：默认绑定

- 什么情况下使用默认绑定呢？**独立函数调用**

  - 独立的函数调用我们可以理解成**函数没有被绑定到某个对象上进行调用**

- 我们通过几个案例来看一下，常见的默认绑定

  ```js
      // 案例一
      function foo() { console.log(this) }
      foo() // 独立函数调用
  
      // 案例二
      function test1() {
          test2() // 独立函数调用
      }
      function test2() {}
      test1() // 独立函数调用
  
      // 案例三. 函数定义在对象中, 但是独立调用
      var obj = {
          name: "later",
          bar: function() { // obj中的bar保存的实际是该函数的引用(内存地址)
              console.log("bar:", this)
          }
      }
  
      var baz = obj.bar // baz在内存中保存的是bar属性中保存函数的内存地址
      baz() // window 这里调用实际就是通过内存地址找到堆内存中的函数，独立调用该函数
  
      function fn1(fn) { fn() }
      fn1(obj.bar) // window 这里传入的是bar对其函数的引用(内存地址)
  ```

## 3. 规则二：隐式绑定

- 另外一种比较常见的调用方式是通过某个对象进行调用的：

  - 也就是它的调用位置中，是**通过某个对象发起的函数调用**
  - 在**调用的对象内部有一个对函数的引用**（比如一个属性）
  - 正是**通过这个引用，间接的将this绑定到了这个对象上**

-  我们通过几个案例来看一下，常见的隐式绑定

  ```js
      // 案例一 
      function foo() { console.log(this) }
      var obj = {
          name: 'later',
          foo: foo
      }
      obj.foo() // obj对象
  
      // 案例二
      function foo() { console.log(this) }
      var obj1 = {
          name: 'obj1',
          foo: foo
      }
      var obj2 = {
          name: 'obj2',
          obj1: obj1
      }
      obj2.obj1.foo() // obj1对象
  
  
      // 案例三
      function foo() { console.log(this) }
      var obj = {
          name: 'obj',
          foo: foo
      }
      var bar = obj.foo
      bar() // window

## 3. 规则三：显式绑定

- 隐式绑定有一个前提条件：

  - 必须在调用的对象内部有一个对函数的引用（比如一个属性）
  - 如果没有这样的引用，在进行调用时，会报找不到该函数的错误
  - 正是通过这个引用，间接的将this绑定到了这个对象上

- 如果我们不希望在对象内部包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？

- JavaScript所有的函数都可以使用**call和apply方法**

  - 第一个参数是相同的，要求传入一个对象

    - 这个对象的作用是什么呢？就是给this准备的
    - 在调用这个函数时，会将this绑定到这个传入的对象上

  - 后面的参数，**`apply`为数组**，**`call`为参数列表**

    ```js
    func.apply(thisArg, [argsArray])
    func.call(thisArg, arg1, arg2, ...)
    ```

- 因为上面的过程，我们**明确的绑定了`this`指向的对象**，所以称之为 **显式绑定**

## 4. 规则四：new绑定

- JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字

- 使用new关键字来调用函数是，会执行如下的操作：

  - 1.创建一个全新的空对象
  - 2.这个新对象会被执行prototype连接
  - 3.这个新对象会被绑定到函数调用的this上（this绑定在这个步骤完成）
  - 4.如果函数没有明确指定返回一个非空对象，表达式会返回新创建的这个对象

  ```js
  function Person(name) {
    console.log(this) // this指向堆内存中新创建的空对象
    console.log(this == p1) // false 因为这时候p1还只是个undefined，并没有将在堆内存中新创建出来的对象赋值给p1
    this.name = name
  }
  
  var p1  = new Person('later')
  console.log(p1) // Person {name: 'later'} 这个时候p1已经拿到创建出来的新对象的内存地址了
  ```
  

## 5. 内置函数的绑定思考

- 有些时候，我们会调用一些JS的内置函数，或者一些第三方库中的内置函数

  - 这些内置函数会要求我们传入另外一个函数
  -  我们自己并**不会显示的调用这些函数**，而且**js内部或者第三方库内部会帮助我们执行**
  - 这些函数中的this又是如何绑定的呢？

- setTimeout、数组的forEach、div的点击

  ```js
  'use strict' // 正常情况下, 默认调用函数是指向window的, 严格模式下, 指向的是undefined
  function foo() { console.log(this) } // window(默认情况) => undefined(严格模式)
  setTimeout(function() {
    console.log(this) // 严格模式下, 定时器中的回调函数中的this仍然指向window，由此可推断出定时器中传入的回调函数可能是显示绑定到window上面的，所以不论默认情况还是严格模式，定时器中回调函数的this都是指向window的
  }, 1000);
  
  var box = document.querySeletcor('.box')
  box.onclick = function() {
    console.log(this === box) // true
  }
  
  var names = ['abc', 'cba', 'nba']
  var obj = {name: 'later'}
  names.forEach(function (item) { // 默认window, 如果传入this参数，则回调函数中this指向传入的参数
    console.log(this) // 三次obj对象
  }, obj)
  ```


# 二. apply、call、bind(创建绑定this的函数)

---

- 通过call或者apply绑定this对象

  - 显示绑定后，this就会明确的指向绑定的对象

    ```js
    function bar() { console.log(this) }
    
    bar.call({name: 'later'}) // {name: 'later'}
    bar.call(123) // Number对象，存放123
    
    // call/apply
    function foo(name, age, height) {
        console.log("foo函数被调用:", this)
        console.log("打印参数:", name, age, height)
    }
    
    
    // apply
    // 第一个参数: 绑定this
    // 第二个参数: 传入额外的实参, 以数组的形式
    // foo.apply("apply", ["kobe", 30, 1.98])
    
    // call
    // 第一个参数: 绑定this
    // 参数列表: 后续的参数以多参数的形式传递, 会作为实参
    foo.call("call", "james", 25, 2.05)
    ```
    

- 如果我们希望一个函数总是显示的绑定到一个对象上，可以怎么做呢？

  - 使用bind方法，bind() 方法**不会调用该函数**，**而是创建一个新的绑定了this的函数**（bound function，BF）
  - 绑定函数是一个 exotic function object（怪异函数对象，ECMAScript 2015 中的术语）
  - 在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用
  - 注意：`bind()` 的另一个最简单的用法是使一个函数拥有预设的初始参数。只要将这些参数（如果有的话）作为 `bind()` 的参数写在 `this` 后面。当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面
    - 意思就是：**`bind`传入的其余参数，会作为新函数的初始参数，而新函数调用时传入的参数会在这些初始参数之后**


  ```js
  function bind(thisArg[, arg1[, arg2[, ...]]])
  
  function foo(name, age, height, address) {
    console.log("foo:", this)
    console.log("参数:", name, age, height, address)
  }
  
  var obj = { name: "why" }
  
  // 需求: 调用foo时, 总是绑定到obj对象身上(不希望obj对象身上有函数)
  // 1. bind函数的基本使用
  // var bar = foo.bind(obj)
  // bar() // this -> obj
  
  // 2. bind函数的其他参数(了解)
  var bar = foo.bind(obj, "kobe", 18, 1.88)
  bar("james")
  ```

# 三. this绑定优先级

---

- 学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？

- **1.默认规则的优先级最低**

  - 毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定this

- **2.显示绑定优先级高于隐式绑定**

  ```js
  var obj = {
      foo: function() {
          console.log(this)
      }
  }
  
  obj.foo.call('haha') // String {'haha'}
  ```

- **3.bind绑定优先级高于apply/call**

  ```js
  function func() { console.log(this) }
  var func2 = func.bind('haha')
  func2.call('hehe') // String {'haha'}
  func2.apply('hehe') // String {'haha'}
  ```

- **3.new绑定优先级最高**

  - new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高	
  - new绑定可以和bind一起使用，new绑定优先级更高

  ```js
  function func() { console.log(this) }
  var func2 = func.bind('haha')
  new func2() // func {}
  ```

# 四. 绑定之外的情况

---

## 1. this规则之外 – 忽略显示绑定

- 我们讲到的规则已经足以应付平时的开发，但是总有一些语法，超出了我们的规则之外。（神话故事和动漫中总是有类似这样的人物）

- 情况一：如果在**显示绑定中**，我们**传入一个null或者undefined**，那么这个**显示绑定会被忽略**，**使用默认规则**：

  - 严格模式下，显示绑定null或undefined，this指向的是原生基本数据类型
  - 非严格模式下，显示绑定null或undfined，this指向window
    - **因为null和undefined没有对应的包装类型**

  ```js
  function foo() { console.log(this) }
  var obj  = {
      name: 'why'
  }
  
  foo.call(obj) // obj对象 => obj对象(严格模式下)
  foo.call('abc') // String {'abc'} => 'abc'(严格模式下)
  foo.call(null) // window => null(严格模式下)
  foo.apply(undefined) // window =>  undefined(严格模式下)
  
  var bar = foo.bind(null)
  bar() // window => null(严格模式下)
  ```

## 2. this规则之外 - 间接函数引用

- 情况二：创建一函数的间接引用，这种情况使用默认绑定规则

  - 赋值`(obj2.foo = obj1.foo)`的结果是foo函数
  - `foo`函数被直接调用，那么是默认绑定

  ```js
  function foo() { console.log(this) }
  var obj1  = {
      name: 'obj1',
      foo: foo
  }
  
  var obj2 = {
      name: 'obj2'
  }
  
  obj1.foo(); // obj1对象
  (obj2.foo = obj1.foo)() // window 圆括号会当成一个表达式去解析，而该表达式内部在赋值的同时，也会返回表达式右侧的值(即obj1中的foo属性所指向的函数)，所以这里是会当成一个独立的函数调用
  ```

## 3. this规则之外 – ES6箭头函数的this使用

- 箭头函数不使用this的四种标准规则（也就是**不绑定this**），而是**根据外层作用域来决定this**

- 我们来看一个模拟网络请求的案例：

  - 这里我使用setTimeout来模拟网络请求，请求到数据后如何可以存放到data中呢？
  - 我们需要拿到obj对象，设置data； 
  - 但是直接拿到的this是window，我们需要在外层定义：var _this = this
  - 在setTimeout的回调函数中使用_this就代表了obj对象

  ```js
  var obj = {
      data: [],
      getData: function() {
  		var _this = this; // 当通过obj.getData调用函数时，函数内部的this绑定到了obj对象，定义一个函数内部的变量_this指向函数内部的this，当执行setTimeout中的回调函数时，其中的this是执行window的，因为setTimeout中的函数是显示绑定到window身上的，所以其内部的回调函数中this执行的就是window了，当我们使用_this变量，会往上层作用域一层一层往查找该变量，最后在上层函数作用域中找到_this变量
          setTimeout(function() {
              // 模拟获取到的数据
              var res = ['abc', 'cba']
              _this.data.push(...res)
          }, 1000)
      }
  }
  
  obj.getData()
  ```

# 五. 箭头函数的使用

---

## 1. 箭头函数 arrow function

- 箭头函数是ES6之后增加的一种编写函数的方法，并且它比函数表达式要更加简洁：

  - 箭头函数**不会绑定this、arguments属性**
  - 箭头函数**不能作为构造函数来使用**（不能和`new`一起来使用，会抛出错误）
    - 所以箭头函数是没有显式原型的，但是作为对象是有隐式原型

- 箭头函数如何编写呢？

  - (): 函数的参数
  - {}: 函数的执行体

  ```js
  // 1.之前的方式
  function foo1() {}
  var foo2 = function(name, age) {
      console.log("函数体代码", this, arguments)
      console.log(name, age)
  }
  
  // 2.箭头函数完整写法
  var foo3 = (name, age) => {
      console.log("箭头函数的函数体")
      console.log(name, age)
  }
  
  // 3.箭头函数的练习
  // 3.1. forEach
  var names = ["abc", "cba", "nba"]
  names.forEach((item, index, arr) => {
      console.log(item, index, arr)
  })
  // 3.2. setTimeout
  setTimeout(() => {
      console.log("setTimeout")
  }, 3000)
  ```

## 2. 箭头函数的编写优化

- 优化一：如果**只有一个参数可以省略()**

  ```js
  nums.forEach(item => {})
  ```

- 优化二：如果**函数执行体中只有一行代码(除return)，可以省略大括号**，且**会自动返回该行代码的返回值**

  - 如果函数体中只有一行代码，有return的时候，不能省略大括号，可以直接去掉return，因为这行代码的返回值会作为整个函数的返回值

  ```js
  nums.forEach(item => console.log(item))
  nums.filter(item => item % 2 == 0)
  ```

- 优化三：如果函数执行体**返回值是一个对象**，那么**需要给这个对象加上()**

  - 因为如果不加的话，js引擎会解析成函数{}的执行体

  ```js
  var foo = () => {
      return {name: 'abc'}
  }
  var bar = () => ({name: 'abc'})
  ```

# 六. 箭头函数this的查找规则

---

- 之前的代码在ES6之前是我们最常用的方式，从ES6开始，我们会使用箭头函数：

  - 为什么在setTimeout的回调函数中可以直接使用this呢？
  - 因为**箭头函数不绑定this对象**，那么this引用就会**从上层作用域中找到对应的this**
    - 所以this绑定对箭头函数是无效的
  - **箭头函数中是没有this的，其中this是往上层作用域一层一层查找，如果都没有，就是window**
    - 而**函数的作用域链是在函数声明的时候就确定下来了**
  
  ```js
      var obj = {
        data: [],
        getData: function() {
           setTimeout(() => {
             var res = ['abc', 'cba']
             console.log(this) 
               this.data.push(...res)
           }, 1000)
        }
      }
      obj.getData() // obj对象
  
      var obj2 = {
        getData: () => {
          setTimeout(() => {
            console.log(this)
          }, 1000)
         }
      }
      obj2.getData() // window 因为箭头函数中是没有this的，是往上层作用域一层一层查找的，最外层this指向window对象
  ```
  

# 七. this面试题分析

---

```js
var name = 'window'
var person = {
    name: 'person',
    sayName: function() {
		console.log(this.name)
    }
}

function sayName() {
    var sss = person.sayName;
    sss() // 'window' 默认绑定
    person.sayName(); // 'person' 隐式绑定
    (person.sayName)(); // 'window' 错了 => 'person' 隐式绑定
    // 等同于person.sayName(), 加小括号不加效果完全一样，加小括号控制代码优先级，不加小括号，本身点.语法优先级就很高
    (b = person.sayName)() // 'window' 间接函数引用 赋值语句返回结果即独
}
sayName()
```

```js
var name = 'window'
var person1 = {
    name: 'person1',
    foo1: function() {
		console.log(this.name)
    },
    foo2: () => console.log(this.name),
    foo3: function() {
        return function() {
            console.log(this.name)
        }
    },
    foo4: function() {
        return () => {
            console.log(this.name)
        }
    }
}

var person2 = {name: 'person2'}

person1.foo1() // 'person1' 隐式绑定
person1.foo1.call(person2) // 'person2' 显式绑定

person1.foo2() // 'window' 上层作用域查找this
person1.foo2.call(person2) // 'window' 不绑定this，上层作用域查找this

person1.foo3()() // 'window' 默认绑定 拿到返回的普通函数直接进行默认调用
person1.foo3.call(person2)() // 'window' 默认绑定 拿到返回的普通函数直接进行默认调用
person1.foo3().call(person2) // 'person2' 显式绑定

person1.foo4()() // 'window' 错了 => 'person1' 箭头函数调用会从上层作用域查找this
person1.foo4.call(person2)() // 'window' 错了 => 'person2' 箭头函数调用会从上层作用域查找this
person1.foo4().call(person2) // 'window' 错了 => 'person1' 箭头函数不绑定this，从上层作用域查找this
```

```js
var name = 'window'
function Person(name) {
    this.name = name
    this.foo1 = function() {
        console.log(this.name)
    }
    this.foo2 = () => console.log(this.name)
    this.foo3 = function() {
        return function() {
            console.log(this.name)
        }
    }
    this.foo4 = function() {
        return () => {
            console.log(this.name)
        }
    }
}

var person1 = new Person('person1')
var person2 = new Person('person2')

person1.foo1() // 'person1' 隐式绑定
person1.foo1.call(person2) // 'person2' 显式绑定

person1.foo2() // 'person1' 上层作用域查找：上层作用域中的this绑定到了person1
person1.foo2.call(person2) // 'person1' 不绑定this，上层作用域查找

person1.foo3()() // 'window' 默认绑定 独立函数调用
person1.foo3.call(person2)() // 'window' 默认绑定 独立函数调用
person1.foo3().call(person2) // 'person2' 显式绑定

person1.foo4()() // 'person1' 上层作用域查找
person1.foo4.call(person2)() // 'person2' foo4函数中this绑定person2，箭头函数查找上层作用域foo4函数中的this
person1.foo4().call(person2) // 'person1' 箭头函数不绑定this，上层作用域查找
```

```js
var name = 'window'
function Person(name) {
    this.name = name
    this.obj = {
        name: 'obj',
        foo1: function() {
			return function() {
				console.log(this.name)
            }
        },
        foo2: function() {
			return () => {
				console.log(this.name)
            }
        }
    }
}

var person1 = new Person('person1')
var person2 = new Person('person2')

person1.obj.foo1()() // 'window' 普通函数默认调用（独立函数调用）
person1.obj.foo1.call(person2)() // 'window' 普通函数默认调用（独立函数调用）
person1.obj.foo1().call(person2) // 'person2' 普通函数显式绑定调用

person1.obj.foo2()() // 'obj' 上层作用域中查找到foo2函数作用域中的this隐式绑定obj
person1.obj.foo2.call(person2)() // 'person2' 上层作用域中查找到foo2函数作用域中的this显式绑定person2
person1.obj.foo2().call(person2) // 'obj' 箭头函数不绑定this，上层作用域中查找到foo2函数作用域中的this隐式绑定obj
```

- 结论：
  - **普通函数中的this，是根据调用的时候绑定的**
  - **箭头函数中是没有this的，所以是不被绑定的，会去上层作用域中查找this，是根据执行上下文决定的**

# 八. 手写`apply`、`call`、`bind`

---

```js
Function.prototype.executionFn = function(thisArg, args) {
    thisArg = ( thisArg == null || thisArg == undefined ) ? window : Object(thisArg) // 这里是防止传入绑定的参数为空或者是原始类型的值，如string或number
    Object.defineProperty(thisArg, '_this', {
        configurable: true,
        enumerable: false，
        value: this
    })
    args ? thisArg._this(...args) : thisArg._this()
    delete this._this
}

/**
* 私有的apply方法
* @param {any} thisArg 传入的绑定对象
* @param {Array} args 传入的参数数组
*/
Function.prototype._apply = function(thisArg, args) {
    // thisArg = ( thisArg == null || thisArg == undefined ) ? window : Object(thisArg)
    // thisArg._this = this
    // Object.defineProperty(thisArg, '_this', {
    //   configurable: true,
    //   enumerable: false
    // })
    // args ? thisArg._this(...args) : thisArg._this()
    this.executionFn(thisArg, args)
}

function foo(name, age) {
    console.log(this, name, age)
}

foo._apply({name: 'later'}, ['later', 18])
foo._apply('abc', ['later', 18])
foo._apply()

/**
* 私有的call方法
* @param {any} thisArg 传入的绑定对象
* @param {Array} args 传入的参数列表
*/
Function.prototype._call = function(thisArg, ...args) {
    // thisArg = ( thisArg == null || thisArg == undefined ) ? window : Object(thisArg)
    // thisArg._this = this
    // Object.defineProperty(thisArg, '_this', {
    //   configurable: true,
    //   enumerable: false
    // })
    // args ? thisArg._this(...args) : thisArg._this()
    this.executionFn(thisArg, args)
}

foo._call()
foo._call({name: 'later'}, 'later', 18)
foo._call('abc', 'later', 18)
```

```js
/**
* 私有的bind方法
* @param {any} thisArg 传入的绑定对象
* @param {Array} args 传入的参数列表
*/
Function.prototype._bind = function(thisArg, ...args) {
    thisArg = ( thisArg == null || thisArg == undefined ) ? window : Object(thisArg)
    Object.defineProperty(thisArg, '_this', {
        configurable: true,
        enumerable: false,
        value: this
    })

    return (...rest) => {
        args ? thisArg._this(...args, ...rest) : thisArg._this(...rest)
    }
}

var foo2 = foo._bind( {name: 'later'}, 'later')
foo2(23)
foo2(18)
foo2()
var foo3 = foo._bind()
foo3()
```





