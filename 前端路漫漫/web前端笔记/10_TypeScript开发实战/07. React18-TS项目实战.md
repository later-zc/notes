# 一. 项目介绍 - 网易云音乐

---

<img src="assets/image-20221110155444831.png" alt="image-20221110155444831" style="zoom:80%;" />

<img src="assets/image-20221110155459812.png" alt="image-20221110155459812" style="zoom:80%;" />

<img src="assets/image-20221110155520252.png" alt="image-20221110155520252" style="zoom:80%;" />

# 二. 项目搭建

---

- 早期创建的`react`项目，默认使用的是`yarn`包管理工具（因为早期`npm`不如`yarn`）

- 创建`TS + react`项目方式：

  - 方式一（基本不采用）：

    - `create-react-app`的方式创建一个项目，然后手动从零配置`TS`
    - 弊端一：
      - `react`是基于`webpack`创建的项目，所有的配置默认是隐藏的，即使通过`eject`暴露配置，但是修改配置是很麻烦的（比从零配置还麻烦），也很容易配置失败

    - 弊端二：
      - `TS`的配置涉及到的东西比较多麻烦（有难度）
      - `TS`代码最终是要编译成`js`代码的
        - `TypeScript Complier（tsc）`：类型检测
        - `babel`：最终转换为`js`

  - 方式二：

    - `create-react-app`脚手架
    - 同时配置`TypeScript`的支持

    ```shell
    create-react-app react-ts-music --template typescript
    ```

  
  - 项目配置：
  
    - 配置项目的`icon`
  
    - 配置项目的标题
  
    - 配置项目别名等（`craco.config.ts`） 
  
      ```js
      // craco.config.js
      
      const path = require('path')
      
      const resolve = (dir) => path.resolve(__dirname, dir)
      
      module.exports = {
        webpack: {
          alias: {
            '@': resolve('src'),
          },
        },
      }
      ```
  
    - 配置`tsconfig.json`
  
      - `baseUrl`：指定解析非相对模块名所基于的目录
      - `paths`：指定`TS`如何解析你的`require/imports`中的导入
  
      ```json
      // tsconfig.json
      
      {
        "compilerOptions": {
          // ...
        + "baseUrl": ".",
        + "paths": {
        +   "@/*": ["./src/*"]
        + }
        },
      }
      ```
  





# 三. 项目目录结构划分

---

- 对项目进行目录结构的划分

  <img src="assets/image-20221113000948728.png" alt="image-20221113000948728" style="zoom:80%;" />





# 四. CSS样式的重置

---

- 对默认`CSS`样式进行重置: 
  - `normalize.css`
  
  - `reset.less`
  
    <img src="assets/image-20221113001119359.png" alt="image-20221113001119359" style="zoom:80%;" />

- 即使在入口文件进行引入，默认`less`文件是会被忽略的（不起作用）<img src="assets/image-20221113002630833.png" alt="image-20221113002630833" style="zoom:80%;" />

- 安装`craco-less`

  - `craco-less@2.0.0`对等依赖的是`@craco/craco@^6.0.0`
  - 而我们这里使用的是`@craco/craco@7.0.0`，所以安装`alpha`版本

  ```shell
  npm i craco-less@alpha -D
  ```

- `craco.config.js`文件新增配置如下，`antd`这里没有还没引入

  ```js
  // craco.config.js
  
  const resolve = (dir) => path.resolve(__dirname, dir)
  const CracoLessPlugin = require('craco-less')
  
  module.exports = {
    plugins: [
      {
        plugin: CracoLessPlugin
      }
    ],
    // ...
  }
  ```

- `less`引入细节具体可查看`react`部分第`8`节的通过`craco`引入`less`






# 五. 项目细节

---

## 1. 路由使用.tsx文件

- 路由文件中的`element`属性对应的`<组件xx />`这种写法是`jsx`语法，不能直接在`ts`文件中写`jsx`，所以需要用`tsx`文件

- `tsx`文件中，使用`JSX`时，`React`必须在作用域内，所以需要引入`React`


## 2. 函数组件参数类型注解方式

- 方式一：

  ```tsx
  interface IProps {
    name: string
    age: number
    height?: number
  }
  
  const Download = (props: IProps) => {
    return (
      <div>
        <span>{props.name}</span>
        <span>{props.age}</span>
      </div>
    )
  }
  // 弊端：没有函数组件本身的一些属性的类型提示
  Download.defaultProps = {}
  ```

- 方式二：

  ```tsx
  // type FC = FunctionComponent
  const Download: React.FC<IProps> = (props) => {
    return (
      <div>
        <span>{props.name}</span>
        <span>{props.age}</span>
      </div>
    )
  }
  // 相比于上方式一：有函数组件自身相关的一些属性的类型提示
  Download.defaultProps = {}
  ```

## 3. React.FC类型的children属性的变化

- 当我们一个函数组件的类型注解为`Reatc.FC`时，如果该组件在实例化使用时，内部还嵌套了其他元素或组件时，场景如下：

  ```tsx
  import React from 'react'
  
  interface IProps {
    name: string
    age: number
    height?: number
  }
  
  const Download: React.FC<IProps> = (props) => {
    return (
      <div>
        <span>{props.name}</span>
        <span>{props.age}</span>
      </div>
    )
  }
  
  // 外部使用
  <Download name="later-zc" age={23}>
    <div>heheh</div>
    呵呵
  </Download>
  ```

- 目前的`Reatc.FC`（2022.11.13）的类型

  ```typescript
  type FC<P = {}> = FunctionComponent<P>;
  
  interface FunctionComponent<P = {}> {
    (props: P, context?: any): ReactElement<any, any> | null;
    propTypes?: WeakValidationMap<P> | undefined;
    contextTypes?: ValidationMap<any> | undefined;
    defaultProps?: Partial<P> | undefined;
    displayName?: string | undefined;
  }
  ```

- 我们知道组件内部可以通过`children`属性获取到传入的内容，但是目前的`React.FC`类型是没有自带`children`属性的，那就需要手动添加

  ```tsx
  import React from 'react'
  // 统一导入，相较于通过React.xxx的方式更好一些
  import type { FC, ReactNode } from 'react'
  
  interface IProps {
    name: string
    age: number
    height?: number
    // children?: React.ReactNode 等价于下面写法
    children?: ReactNode
  }
  
  // type FC = FunctionComponent
  // const Download: React.FC<IProps> = (props) => { 等价于下面写法
  const Download: FC<IProps> = (props) => {
    return (
      <div>
        <span>{props.name}</span>
        <span>{props.age}</span>
      </div>
    )
  }

- `ReactNode`的类型

  ```typescript
  type ReactNode = ReactElement | string | number | ReactFragment | ReactPortal | boolean | null | undefined;
  ```

- 早期的时候，是可以在组件内部通过`children`属性获取到嵌套在组件内部的内容

- 因为早期的时候，`React.FC`的类型中`props`属性的类型声明，不仅仅只是所传入的泛型，还交叉了另外一个类型`PropsWithChildren`，所以就会自动生成一个`children`属性

  ```typescript
  type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined };
  ```


## 4. 基于useSelector封装的useAppSelector

- 帮助我们可省略在使用`useSelector()`时，每次需要手动添加`state`参数类型注解

- 而是通过`useAppSelector`函数的调用，主动推导出`state`的类型，且为`slice`中的`initialState`的类型

  ```typescript
  // store/index.ts
  
  import { configureStore } from '@reduxjs/toolkit'
  import counterReducer from './modules/counter'
  import { useSelector, TypedUseSelectorHook } from 'react-redux'
  
  const store = configureStore({
    reducer: {
      counter: counterReducer
    }
  })
  
  type GetStateFnType = typeof store.getState
  export type RootStateType = ReturnType<GetStateFnType>
  
  // useAppSelector 辅助函数，省略 state 中的类型注解，自动推导
  // TypedUseSelectorHook 利用调用签名的形式，帮助我们推导出 state 的类型
  export const useAppSelector: TypedUseSelectorHook<RootStateType> = useSelector
  
  export default store
  ```

- `counterSlice`

  ```typescript
  import { createSlice } from '@reduxjs/toolkit'
  
  const counterSilce = createSlice({
    name: 'counter',
    initialState: {
      num: 100,
      age: 18
    },
    reducers: {}
  })
  
  export default counterSilce.reducer
  ```

- 使用

  ```tsx
  import React from 'react'
  import { shallowEqual } from 'react-redux'
  import { useAppSelector } from './store'
  // import { RootStateType } from './store'
  // import store from './store'
  
  // type GetStateFnType = typeof store.getState
  // type RootStateType = ReturnType<GetStateFnType>
  
  function App() {
    const state = useAppSelector( // 此处使用
      (state) => ({
        counter: state.counter.num
      }),
      shallowEqual
    )
  
    return (
      <div className="App">
  </div>
    )
  }
  
  export default App
  ```


## 5. 基于useDispatch封装的useAppDispatch

- 封装

  ```typescript
  // store/index.ts
  
  type DispatchType = typeof store.dispatch
  
  export const useAppDispatch: () => DispatchType = useDispatch
  ```

- 使用：

  ```tsx
  import React from 'react'
  import { shallowEqual } from 'react-redux'
  import { useAppSelector, useAppDispatch } from './store'
  import { changeNumAction } from './store/modules/counter'
  
  function App() {
    const state = useAppSelector(
      (state) => ({
        counter: state.counter.num
      }),
      shallowEqual
    )
  
    const dispatch = useAppDispatch() // 此处使用
    const handleChangeNum = () => dispatch(changeNumAction(20))
  
    return (
      <div className="App"></div>
    )
  }
  
  export default App
  ```

## 6. 基于上面两个的封装，再来个appShallEqual

- 为了不从两个不同中导入，而都从一个文件中导入，将`shallEqual`也封装进去

- 封不封装都可以

  ```typescript
  // store/index.ts
  
  export const appShallowEqual = shallowEqual
  ```

- 使用：

  ```tsx
  import React from 'react'
  import { shallowEqual } from 'react-redux'
  import { useAppSelector, useAppDispatch, appShallowEqual } from './store'
  import { changeNumAction } from './store/modules/counter'
  
  function App() {
    const state = useAppSelector(
      (state) => ({
        counter: state.counter.num
      }),
      appShallowEqual // 此处使用
    )
  
    const dispatch = useAppDispatch()
    const handleChangeNum = () => dispatch(changeNumAction(20))
  
    return (
      <div className="App"></div>
    )
  }
  
  export default App
  ```

  

















