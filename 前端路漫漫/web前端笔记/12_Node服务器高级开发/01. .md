# 一. Node服务器开发

---

## 1. 服务器开发

<img src="assets/image-20230201191455744.png" alt="image-20230201191455744" style="zoom:80%;" />

## 2. Node.js 是什么

- 官方对 `Node.js` 的定义：
  - **`Node.js` 是一个基于 `V8` 引擎（`js`引擎）的 `JavaScript` 运行时环境**
- 也就是说 `Node.js` 基于 `V8` 引擎来执行 `js` 代码，但是不仅仅只有 `V8` 引擎：
  - 前面我们知道 `V8` 可以嵌入到任何 `C ++` 应用程序中，无论是`Chrome` 还是 `Node.js`，事实上都是嵌入了 `V8` 引擎来执行`js` 代码
  - 但是在 `Chrome` 浏览器中，还需要解析、渲染 `HTML`、`CSS` 等相关渲染引擎，另外还需要提供支持浏览器操作的 `API`、浏览器自己的事件循环等
  - 另外，在 `Node.js` 中我们也需要进行一些额外的操作，比如文件系统读/写、网络 `IO`、加密、压缩解压文件等操作

## 3. 浏览器和 Node.js 架构区别

- 我们可以简单理解规划出 `Node.js` 和浏览器的差异：

<img src="assets/image-20230201194251709.png" alt="image-20230201194251709" style="zoom:80%;" />

## 4. Node.js 架构

<img src="assets/image-20230201194519668.png" alt="image-20230201194519668" style="zoom:80%;" />

- 我们来看一个单独的 `Node.js` 的架构图：
  - 我们编写的 `js` 代码会经过 `V8` 引擎，再通过 `Node.js` 的 `Bindings`，将任务放到 `Libuv` 的事件循环中
  - `libuv`（Unicorn Velociraptor — 独角伶盗龙）是使用 `C` 语言编写的库
  - `libuv` 提供了事件循环、文件系统读写、网络 `IO`、线程池等等内容





# 二. fs模块-文件系统

---

## 1. 内置模块 fs

- `fs` 是 `File System` 的缩写，表示文件系统
- **对于任何一个为服务器端服务的语言或框架通常都会有自己的文件系统：**
  - 因为服务器需要将各种数据、文件等放置到不同的地方
  - 比如用户数据可能大多数是放到数据库中的
  - 比如某些配置文件或用户资源（图片、音视频）都是以文件的形式存在于操作系统上的
- **`Node` 也有自己的文件系统操作模块，就是 `fs`：**
  - 借助于 `Node` 帮我们封装的文件系统，我们可以在任何的操作系统（`window`、`Mac OS`、`Linux`）上面直接去操作文件
  - 这也是 `Node` 可以开发服务器的一大原因，也是它可以成为前端自动化脚本等热门工具的原因

## 2. fs 的 API 介绍

- `Node` 文件系统的 `API` 非常的多：
  - https://nodejs.org/docs/latest-v16.x/api/fs.html
  - 我们不可能，也没必要一个个去学习
  - 这个更多的应该是作为一个 `API` 查询的手册，等用到的时候查询即可
  - 学习阶段我们只需要学习最常用的即可
- 但是这些 `API` 大多数都提供三种操作方式：
  - 方式一：**同步操作文件**：代码会被阻塞，不会继续执行
  - 方式二：**异步回调函数操作文件**：代码不会被阻塞，需要传入回调函数，当获取到结果时，回调函数被执行
  - 方式三：**异步 `Promise` 操作文件**：代码不会被阻塞，通过 `fs.promises` 调用方法操作，会返回一个 `Promise`，可以通过 `then`、`catch` 进行处理

## 3. 案例：获取一个文件的状态

- 我们这里以获取一个文件的状态为例：

  ```js
  const fs = require('fs')
  
  // 1.同步读取
  // const res1 = fs.readFileSync('./a.txt')
  // console.log('res1: ', res1.toString())
  const res1 = fs.readFileSync('./a.txt', {
    encoding: 'utf-8',
  })
  console.log('res1: ', res1)
  console.log('同步读取执行完成，才执行后续代码')
  
  // 2.异步读取: 回调函数
  fs.readFile(
    './a.txt',
    {
      encoding: 'utf-8',
    },
    (err, data) => {
      console.log('err: ', err)
      console.log('data: ', data)
    }
  )
  console.log('异步读取，不阻塞后续代码')
  
  // 3.异步读取: Promise
  fs.promises
    .readFile('./a.txt', {
      encoding: 'utf-8',
    })
    .then((res) => {
      console.log('res: ', res)
    })
    .catch((err) => {
      console.log('err: ', err)
    })
  ```

## 4. 文件描述符

- 文件描述符（`File descriptors`）是什么呢？

  - 在常见的操作系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格
  - 每个打开的文件都分配了一个称为文件描述符的简单的数字标识符
  - **在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件**
  - `Windows` 系统使用了一个虽然不同但概念上类似的机制来跟踪资源

- **为了简化用户的工作，`Node.js` 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符**

- **`fs.open()` 方法用于分配新的文件描述符**

  - 一旦被分配，则文件描述符可用于从文件读取数据、向文件写入数据、或请求关于文件的信息

    ```js
    const fs = require('fs')
    
    fs.open('./a.txt', (err, fd) => {
      console.log('err: ', err)
      // 读取文件描述符
      console.log('fd: ', fd)
      // 读取文件的信息
      fs.fstat(fd, (err, stats) => {
        if (err) return
        console.log('stats: ', stats)
        // 手动释放文件 or 关闭进程(基本服务不会关闭的)
        fs.close(fd)
      })
    })
    ```

## 5. 文件的读写

- 如果我们希望对文件的内容进行操作，这个时候可以使用文件的读写：

  - `fs.readFile(path[, options], callback)`：读取文件的内容
  - `fs.writeFile(file, data[, options], callback)`：在文件中写入内容

  ```js
  const fs = require('fs')
  
  // 1.有一段内容（客户端传递过来的http/express/koa）
  const content = 'hello world, hello node'
  
  // 2.文件的写入操作（若文件不存在则自动创建）
  fs.writeFile('./b.txt', content, {flag: ""}, (err) => {
    if (err) {
      console.log('文件写入失败')
    } else {
      console.log('文件写入成功')
    }
  })
  ```

- 在上面的代码中，你会发现有一个对象类型，这个是写入时填写的 `option` 参数：

  - `flag`：写入的方式
  - `encoding`：字符的编码

## 6. flag 选项

- 我们先来看 `flag`：

- `flag` 的值有很多：**https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system_flags**

  - `w` 打开文件写入，文件不存在则创建文件，默认值
  - `w+` 打开文件进行读写（可读可写），如果不存在则创建文件
  - `r` 打开文件读取，读取时的默认值
  - `r+` 打开文件进行读写，如果不存在那么抛出异常
  - `a` 打开要写入的文件，将流放在文件末尾。如果不存在则创建文件
  - `a+` 打开文件以进行读写（可读可写），将流放在文件末尾。如果不存在则创建文件

  > `TIP`：`write`->`w`、`read`->`r`，`append`->`a`

## 7. encoding 选项

- 我们再来看看编码：

  - 在简书上一篇关于字符编码的文章：https://www.jianshu.com/p/899e749be47c
  - 目前基本用的都是 `UTF-8` 编码

- 文件读取：

  - 如果不填写 `encoding`，返回的结果是 `Buffer`

  ```js
  const fs = require('fs')
  
  fs.readFile(
    './a.txt',
    {
      encoding: 'utf-8',
    },
    (err, data) => {
      console.log('err: ', err)
      console.log('data: ', data)
    }
  )
  ```

## 8. 文件夹操作

- 新建一个文件夹

  - 使用 `fs.mkdir()` 或 `fs.mkdirSync()` 创建一个新文件夹

    ```js
    const fs = require('fs')
    
    // 创建文件夹
    fs.mkdir('./test', (err) => {
      console.log('err: ', err)
    })
    ```

  - 获取文件夹的内容

    ```js
    const fs = require('fs')
    
    function readDirectory(dir) {
      fs.readdir(dir, { withFileTypes: true }, (err, files) => {
        console.log('files: ', files)
        files.forEach((item) => {
          if (item.isDirectory()) {
            console.log(item.name, '是一个文件夹')
            readDirectory(`${dir}/${item.name}`)
          } else {
            console.log(item.name, '是一个文件')
          }
        })
      })
    }
    
    readDirectory('./test')
    ```

  - 文件重命名

    ```js
    const fs = require('fs')
    
    // 1.对文件夹进行重命名
    fs.rename('./test', './demo', (err) => {
      console.log(`重命名文件：${err === null ? '成功' : err}`)
    })
    
    // 2.对文件重命名
    fs.rename('./b.txt', './bb.txt', (err) => {
      console.log(`重命名文件：${err === null ? '成功' : err}`)
    })
    ```

    





# 三. event模块-事件处理 

---









# 四. 认识二进制和buffer 

---















# 五. Buffer的创建方式

---











# 六. Buffer的源码解析 

---

























