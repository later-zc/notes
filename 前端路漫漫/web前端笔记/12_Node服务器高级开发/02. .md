# 一. Stream的读写操作 

---

## 1. 认识 Stream

- 什么是 `Stream`（小溪、小河，在编程中通常翻译为流）呢？
  - 我们的第一反应应该是流水，源源不断的流动
  - 程序中的流也是类似的含义，我们可以想象当我们从一个文件中读取数据时，文件的二进制（字节）数据会源源不断的被读取到我们程序中
  - 而这个一连串的字节，就是我们程序中的流
- 所以，我们可以这样理解流：
  - 是连续字节的一种表现形式和抽象概念
  - 流应该是可读的，也是可写的
- 在之前学习文件的读写时，我们**可以直接通过 `readFile` 或者 `writeFile` 方式读写文件，为什么还需要流呢？**
  - 直接读写文件的方式，虽然简单，但是无法控制一些细节的操作
  - 比如从什么位置开始读、读到什么位置、一次性读取多少个字节
  - 读到某个位置后，暂停读取，某个时刻恢复继续读取等等
  - 或者这个文件非常大，比如一个视频文件，一次性全部读取并不合适

## 2. 文件读写的 Stream

- 事实上 `Node` 中很多对象是基于流实现的：
  - `http` 模块的 `Request` 和 `Response` 对象
- 官方文档：另外**所有的流都是 `EventEmitter` 的实例**
- 那么在 `Node` 中都有哪些流呢？
- **`Node.js` 中有四种基本流类型（可写流、可读流、双向流、可变流）**：
  - `Writable`：可以向其写入数据的流（例如 `fs.createWriteStream()`）
  - `Readable`：可以从中读取数据的流（例如 `fs.createReadStream()`）
  - `Duplex`：同时为 `Readable` 和 `Writable`（例如 `net.Socket`）
  - `Transform`：`Duplex`可以在写入和读取数据时修改或转换数据的流（例如 `zlib.createDeflate()`）
- 这里我们通过 `fs` 的操作，讲解一下 `Writable`、`Readable`，另外两个大家可以自行学习一下

## 3. Readable

- 之前我们读取一个文件的信息：

  ```js
  const fs = require('fs')
  
  // 1.一次性读取
  // 缺点一：没有办法精准控制从何处开始读取，及读取到何处截止
  // 缺点二：不能读取到某个位置时，暂停读取，恢复读取
  // 缺点三：文件非常大的时候，无法多次读取
  fs.readFile('./a.txt', (err, data) => {
    console.log('data: ', data)
  })
  ```

- 这种方式是一次性将一个文件中所有的内容都读取到程序（内存）中，但是这种读取方式就会出现我们之前提到的很多问题：
  - 文件过大、读取的位置、结束的位置、一次读取的大小
- 这个时候，我们可以使用 `createReadStream`，我们来看几个参数，更多参数可以参考官网：
  - `start`：文件读取开始的位置（包括该索引位置）
  - `end`：文件读取结束的位置（包括该索引位置）
  - `highWaterMark`：一次性读取字节的长度，默认是`64kb`

## 4. Readable 的使用

- 创建文件的 `Readable`

- 我们如何获取到数据呢？可以通过监听 `data` 事件，获取读取到的数据

- 也可以做一些其他的操作：监听其他事件、暂停或者恢复

  ```js
  // 2.通过流读取文件
  // 2.1 创建一个可读流
  const readStream = fs.createReadStream('./a.txt', {
    start: 2, // 什么位置开始读取
    end: 10, // 结束读取位置
    highWaterMark: 3, // 一次性读取字节的长度
  })
  
  // 2.2 监听读取到的数据
  readStream.on('data', (data) => {
    console.log('data.toString(): ', data.toString())
    readStream.pause() // 暂停读取
    setTimeout(() => {
      readStream.resume() // 恢复读取
    }, 2000)
  })
  
  // 3.补充其他的事件监听
  readStream.on('open', (fd) => {
    console.log('监听到: 通过流将文件打开~, fd: ', fd)
  })
  
  readStream.on('end', () => {
    console.log('监听到: 已经读取到end位置~')
  })
  
  readStream.on('close', () => {
    console.log('监听到：文件读取结束并被关闭')
  })
  ```

## 5. Writable

- 之前我们写入一个文件的方式是这样的：

  ```js
  fs.writeFile(
    './a.txt',
    'hello world',
    {
      flag: 'a+',
    },
    (err, data) => {
      console.log('data: ', data)
    }
  )
  ```

- 这种方式相当于一次性将所有的内容写入到文件中，但是这种方式也有很多问题：

  - 比如我们希望一点点写入内容，精确每次写入的位置等

- 这个时候，我们可以使用 `createWriteStream`，我们来看几个参数，更多参数可以参考官网：

  - `flags`：默认是 `w`，如果我们希望是追加写入，可以使用 `a` 或者 `a+`
  - `start`：写入的位置

## 6. Writable 的使用

- 我们进行一次简单的写入

  ```js
  // 创建一个写入流
  const writeStream = fs.createWriteStream('./a.txt', {
    start: 1,
  })
  
  writeStream.write('666~')
  writeStream.write('666~', (err) => {
    console.log('写入完成~: ', err)
  })
  ```

- 你可以监听 `open` 事件：

  ```js
  writeStream.on('open', () => {
    console.log('文件被打开~')
  })
  ```

## 7. close 的监听

- 我们会发现，我们并不能监听到 `close` 事件：

  - 这是因为写入流在打开后是不会自动关闭的
  - 我们必须手动关闭，来告诉 `Node` 已经写入结束了
  - 并且会发出一个 `finish` 事件的

- 另外一个非常常用的方法是 `end`：**`end`方法相当于做了两步操作：  `write` 传入的数据和调用 `close` 方法**

  ```js
  // 创建一个写入流
  const writeStream = fs.createWriteStream('./a.txt', {
    start: 1,
  })
  
  writeStream.on('open', () => {
    console.log('文件被打开~')
  })
  
  writeStream.write('666~')
  writeStream.write('666~', (err) => {
    console.log('写入完成~: ', err)
  })
  
  writeStream.on('finish', () => {
    console.log('写入完成了~')
  })
  
  writeStream.on('close', () => {
    console.log('文件被关闭~')
  })
  
  // 3.写入完成时, 需手动调用close方法
  // writeStream.close()
  
  // 4. end方法: 将最后的内容写入到文件中，并关闭文件
  writeStream.end('哈哈哈')
  ```

## 8. pipe 方法

- 正常情况下，我们**可以将读取到的 输入流，手动的放到 输出流中进行写入**：

  ```js
  const fs = require('fs')
  
  // 1.方式一：一次性读取和写入文件
  fs.readFile('./b.txt', (err, data) => {
    fs.writeFile('./foo_copy01.txt', data, () => {
      console.log('写入文件完成')
    })
  })
  
  // 2.方式二：创建可读流和可写流
  const readStream = fs.createReadStream('./b.txt')
  const writeStream = fs.createWriteStream('./foo_copy02.txt')
  
  readStream.on('data', (data) => {
    writeStream.write(data)
  })
  
  readStream.on('end', () => {
    writeStream.close()
  })
  ```

- 我们也可以通过 `pipe`（管道） 来完成这样的操作：

  ```js
  // 3.在可读流和可写流之间建立一个管道
  // 可读流中读取到的数据直接放到可写流中
  const readStream = fs.createReadStream('./b.txt')
  const writeStream = fs.createWriteStream('./foo_copy03.txt')
  readStream.pipe(writeStream)
  ```

  



# 二. http模块web服务

---











# 三. request请求对象 

---











# 四. response响应对象

---











# 五. axios node中使用

---















# 六. 文件上传的细节分析

---



















