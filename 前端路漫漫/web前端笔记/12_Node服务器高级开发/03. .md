# 一. Express 初体验 

---

## 1. 认识 Web 框架

- 前面我们已经学习了使用 `http` 内置模块来搭建 `Web` 服务器，为什么还要使用框架？

  - 原生 `http` 在进行很多处理时，会较为复杂
  - 有 `URL` 判断、`Method` 判断、参数处理、逻辑代码处理等，都需要我们自己来处理和封装
  - 并且所有的内容都放在一起，会非常的混乱
- 目前在 `Node` 中比较流行的 `Web` 服务器框架是 `express`、`koa`

  - 我们先来学习 `express`，后面再学习 `koa`，并且对他们进行对比
- `express` 早于 `koa` 出现，并且在 `Node` 社区中迅速流行起来：
  - 我们可以基于 `express` 快速、方便的开发自己的 `Web` 服务器
  - 并且可以通过一些实用工具和中间件来扩展自己功能

- **`Express` 整个框架的核心就是中间件，理解了中间件其他一切都非常简单！**

## 2. Express 安装

- `express` 的使用过程有两种方式：

  - 方式一：通过 `express` 提供的脚手架，直接创建一个应用的骨架
  - 方式二：从零搭建自己的 `express` 应用结构

- 安装 `express`：

  ```js
  npm i express
  ```

- 方式一：安装 `express-generator`

  ```bash
  # 安装脚手架
  npm i -g express-generator
  
  # 创建项目
  express express-demo
  
  # 安装依赖
  npm i 
  
  # 启动项目
  node bin/www
  ```

- 方式二：从零搭建自己的 `express` 应用结构

  ```bash
  npm init -y # 如果报错文件夹名字有问题，则使用 npm init
  ```

## 3. Express 的基本使用

- 我们来创建第一个 `express` 项目：

  - 我们会发现，之后的开发过程中，可以方便的将请求进行分离
  - 无论是不同的 `URL`，还是 `get`、`post` 等请求方式
  - 这样的方式非常方便我们已经进行维护、扩展
  - 当然，这只是初体验，接下来我们来探索更多的用法

- 请求的路径中如果有一些参数，可以这样表达：

  - `/users/:userId`
  - 在 `request` 对象中获取该参数可以通过 `req.params.userId`

- 返回数据，我们可以方便的使用 `json`：

  - `res.json(数据)` 方式
  - 可以支持其他的方式，可以自行查看文档
  - https://www.expressjs.com.cn/guide/routing.html

  ```js
  const express = require('express')
  
  // 1.创建express的服务器
  const app = express()
  
  // 客户端访问URL：/login 和 /home
  app.post('/login', (req, res) => {
    res.end('登录成功 ~')
  })
  
  app.get('/home', (req, res) => {
    res.end('访问home页面数据 ~')
  })
  
  // 2. 启动服务器，并且监听端口
  app.listen(9000, () => {
    console.log('express server running ~')
  })
  ```






# 二. Express 中间件使用

---

## 1. 认识中间件

- `Express` 是一个路由和中间件的 `Web` 框架，它本身的功能非常少：
  - `Express` 应用程序本质上是一系列中间件函数的调用
- 中间件是什么呢？
  - **中间件的本质 是传递给 `express` 的一个回调函数**
  - 这个回调函数接受三个参数：
    - 请求对象（`request` 对象）
    - 响应对象（`response` 对象）
    - `next` 函数（在 `express` 中定义的用于执行下一个中间件的函数）

- 中间件中可以执行哪些任务呢？

  - 执行任何代码
  - 对请求（`request`）和响应（`response`）对象进行更改
  - 结束请求 - 响应周期（返回数据）
  - 调用堆栈中的下一个中间件

- 如果当前中间件功能没有结束请求-响应周期，则必须调用 `next()` 将控制权传递给下一个中间件功能，否则，请求将被挂起

  <img src="assets/image-20230206203539436.png" alt="image-20230206203539436" style="zoom:80%;" />

```js
const express = require('express')

// 创建express的服务器
const app = express()

// 给express创建的app传入一个回调函数
// 传入的这个回调函数就称之为中间件(middleware)
// app.post('/login', callback) // callback => 中间件
app.post('/login', (req, res, next) => {
  console.log('first middleware exec ~')

  // 1.中间件中可以执行任意代码
  // 打印
  // 查询数据
  // 逻辑代码

  // 2.在中间件中可以修改req/res对象
  req.abc = 99

  // 3.可以在中间件中结束响应周期
  // res.json({
  //   message: '登录成功',
  //   code: 0,
  // })

  // 4.执行下一个中间件（当响应周期未结束时）
  next()
})

app.use((req, res, next) => {
  console.log('second middleware exec ~')
})

// 2. 启动服务器，并且监听端口
app.listen(9000, () => {
  console.log('express server running ~')
})
```

## 2. 应用中间件 – 自己编写

- 那么，如何将一个中间件应用到我们的应用程序中呢？

  - `express` 主要提供了两种方式：
    - `app/router.use`
    - `app/router.methods`
  - 可以是 `app`，也可以是 `router`，`router` 我们后续再学习
  - `methods` 指的是常用的请求方式，比如： `app.get` 或 `app.post` 等

- 我们先来学习 `use` 的用法，因为 `methods` 的方式本质是 `use` 的特殊情况

  - 案例一：最普通的中间件

    ```js
    const express = require('express')
    const app = express()
    
    // 通过use方法注册的中间件是最普通/简单的中间件
    // 通过use注册的中间件，无论是什么请求方式/路径，都可以匹配上
    app.use((req, res, next) => {
      console.log('normal middleware exec ~')
    })
    
    // 2. 启动服务器，并且监听端口
    app.listen(9000, () => {
      console.log('express server running ~')
    })
    ```

  - 案例二：`path` 匹配中间件

    ```js
    const express = require('express')
    const app = express()
    
    // 注册普通的中间件
    // app.use((req, res, next) => {
    //   res.end('------')
    // })
    
    // 注册路径匹配的中间件
    // 路径匹配的中间件是不会对请求方式有限制的
    app.use('/home', (req, res, next) => {
      console.log('match /home middleware ~')
      res.end('home data')
    })
    
    app.listen(9000, () => {
      console.log('express server running ~')
    })
    ```

  - 案例三：`path` 和 `method` 匹配中间件

    ```js
    const express = require('express')
    const app = express()
    
    // 注册中间件：对path/method都有限制
    // app.method(path, middleware)
    app.get('/home', (req, res, next) => {
      console.log('match /home get method middleware')
      res.end('home data')
    })
    
    app.post('/users', (req, res, next) => {
      console.log('match /users post middleware')
      res.end('users data')
    })
    
    app.listen(9000, () => {
      console.log('express server running ~')
    })
    ```

  - 案例四：注册多个中间件

    ```js
    const express = require('express')
    const app = express()
    
    // app.get(路径，中间件1，中间件2，...)
    app.get(
      '/home',
      (req, res, next) => {
        console.log('111')
        next() // 执行下一个中间件
        res.end('home data')
      },
      (req, res, next) => {
        console.log('222')
        // 不会执行下一个中间件
        // 当前中间件中未调用next方法
      },
      (req, res, next) => {
        console.log('333')
      }
    )
    
    app.listen(9000, () => {
      console.log('express server running ~')
    })
    ```

> 总结：
>
> - 当 `express` 接收到客户端发送的请求时，在所有中间件中开始进行匹配
> - **当匹配到第一个符合要求的中间件时，那么就会执行第一个匹配到的中间件**
> - **后续的中间件是否执行？取决于当前中间件中是否执行 `next` 方法**









# 三. Express 请求和响应

---



















# 四. Express 路由的使用

---



























# 五. Express 的错误处理

---

















# 六. Express 的源码解析

---























