# 一. MySQL 的聚合函数 

---

## 1. 聚合函数

- 聚合函数表示 **对值的集合 进行操作的 组函数（集合函数）**

  ```mysql
  # 1.计算华为手机的平均价格
  SELECT AVG(price) FROM `products` WHERE `brand` = '华为';
  
  # 2.计算小米手机的平均评分
  SELECT AVG(score) FROM `products` WHERE `brand` = '小米';
  
  # 3.计算手机中最高和最低的评分
  SELECT MAX(score) FROM products;
  SELECT MIN(score) FROM products;
  
  # 4.计算总投票人数
  SELECT SUM(voteCnt) FROM products;
  
  # 5.计算所有条目的数量
  SELECT COUNT(*) FROM products;
  # 6.计算华为手机的个数
  SELECT COUNT(*) FROM products WHERE brand = '华为';
  ```

  <img src="assets/image-20230410223211263.png" alt="image-20230410223211263" style="zoom:80%;" />

## 2. 认识 Group By

- 事实上**聚合函数相当于默认将所有的数据分成了一组**：
  - 我们前面使用 `avg` 还是 `max` 等，都是将所有的结果看成一组来计算的
  - 那么如果我们希望划分多个组：比如华为、苹果、小米等手机分别的平均价格，应该怎么来做呢？
  - 这个时候我们可以使用 `GROUP BY`
  
- **`GROUP BY` 通常和聚合函数一起使用**：
  - **表示我们先对数据进行分组，再对每一组数据，进行聚合函数的计算**
  
- 我们现在来提一个需求：
  - 根据品牌进行分组
  
  - 计算各个品牌中：商品的个数、平均价格
  
  - 也包括：最高价格、最低价格、平均评分
  
    ```mysql
    # group by：数据根据品牌进行分组
    SELECT 
    	brand, MAX(price), MIN(price), ROUND(AVG(price), 2), ROUND(AVG(score), 2)
    FROM products
    GROUP BY brand; 
    	
    # 添加别名：直接在后面写 或者 使用as/AS
    SELECT 
    	brand, MAX(price) maxPrice, MIN(price) minPrice, ROUND(AVG(price), 2) as avgPrice, ROUND(AVG(score), 2) AS avgScore
    FROM products
    GROUP BY brand; 
    ```

## 3. Group By 的约束条件

- 如果我们希望**给 `Group By` 查询到的结果添加一些约束，可以使用：`HAVING`**

- 比如：如果我们还希望筛选出平均价格在4000以下，并且平均分在7以上的品牌：

  ```mysql
  SELECT 
  	brand, MAX(price) maxPrice, MIN(price) minPrice, ROUND(AVG(price), 2) as avgPrice, ROUND(AVG(score), 2) AS avgScore
  FROM products
  GROUP BY brand
  HAVING avgPrice < 4000 AND avgScore > 7; 
  ```






# 二. MySQL 的外键约束

---

## 1. 创建多张表

- 假如我们的上面的商品表中，对应的品牌还需要包含其他的信息：

  - 比如品牌的官网，品牌的世界排名，品牌的市值等等

- 如果我们直接在商品中去体现品牌相关的信息，会存在一些问题：

  - 一方面，`products` 表中应该表示的都是商品相关的数据，应该又另外一张表来表示 `brand` 的数据
  - 另一方面，多个商品使用的品牌是一致时，会存在大量的冗余数据

- 所以，我们可以将所有的品牌数据，单独放到一张表中，创建一张品牌的表：

  ```mysql
  CREATE TABLE IF NOT EXISTS `brand`(
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(20) NOT NULL,
    website VARCHAR(100),
    worldRank INT
  );
  ```

## 2. 插入模拟数据

- 插入模拟的数据：

  - 这里我是刻意有一些商品数据的品牌是没有添加的
  - 并且也可以添加了一些不存在的手机品牌

  ```mysql
  INSERT INTO `brand` (name, website, worldRank) VALUES ('华为', 'www.huawei.com', 1);
  INSERT INTO `brand` (name, website, worldRank) VALUES ('小米', 'www.mi.com', 10);
  INSERT INTO `brand` (name, website, worldRank) VALUES ('苹果', 'www.apple.com', 5);
  INSERT INTO `brand` (name, website, worldRank) VALUES ('oppo', 'www.oppo.com', 15);
  INSERT INTO `brand` (name, website, worldRank) VALUES ('京东', 'www.jd.com', 3);
  INSERT INTO `brand` (name, website, worldRank) VALUES ('Google', 'www.google.com', 8);
  ```

## 3. 创建外键

- 将两张表联系起来，我们可以将 `products` 中的 `brand_id` 关联到 `brand` 中的 `id`：

  - **如果是创建表添加外键约束**，我们需要在创建表的`()`中的添加如下语句

    ```mysql
    FOREIGN KEY (brand_id) REFERENCES brand(id)
    ```

  - **如果是表已经创建好，额外添加外键**：

    ```mysql
    ALTER TABLE `products` ADD `brand_id` INT;
    ALTER TABLE `products` ADD FOREIGN KEY (brand_id) REFERENCES brand(id);
    ```

- 现在我们可以将 `products` 中的 `brand_id` 关联到 `brand` 中的 `id` 的值：

  ```mysql
  UPDATE `products` SET `brand_id` = 1 WHERE `brand` = '华为';
  UPDATE `products` SET `brand_id` = 4 WHERE `brand` = 'OPPO';
  UPDATE `products` SET `brand_id` = 3 WHERE `brand` = '苹果';
  UPDATE `products` SET `brand_id` = 2 WHERE `brand` = '小米';
  ```

## 4. 外键存在时更新和删除数据

- 我们来思考一个问题：

  - 如果 `products` 中引用的外键被更新了或者删除了，这个时候会出现什么情况呢？

- 我们来进行一个更新操作：比如将华为的 `id` 更新为100

  ```mysql
  UPDATE `brand` SET id = 100 WHERE id = 1;
  ```

- 这个时候执行代码是报错的：

  <img src="assets/image-20230413210415389.png" alt="image-20230413210415389" style="zoom:80%;" />

## 5. 如何进行更新呢？

- 如果我希望可以更新呢？我们需要修改 `ondelete` 或者 `onupdate` 的值

- 我们可以给更新或者删除时设置几个值：

  - `RESTRICT`(**默认属性**)：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话会报错的，不允许更新或删除（`MySQL`中定义的标准）
  - `NO ACTION`：和 `RESTRICT` 是一致的，是在 `SQL` 标准中定义的
  - `CASCADE`：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话：
    - 更新：那么会更新对应的记录
    - 删除：那么关联的记录会被一起删除掉
  - `SET NULL`：当更新或删除某个记录时，会检查该记录是否有关联的外键记录，有的话，将对应的值设置为 `NULL`

  ```mysql
  # 删除外键约束
  ALTER TABLE products DROP FOREIGN KEY products_ibfk_1;
  # 设置ondelete和onupdate 的值
  ALTER TABLE products ADD FOREIGN KEY (brand_id) REFERENCES brand(id)
  	ON UPDATE CASCADE
  	ON DELETE CASCADE;
  ```





# 三. MySQL 的多表查询

---

## 1. 什么是多表查询？

- 如果我们希望查询到产品的同时，显示对应的品牌相关的信息，因为数据是存放在两张表中，所以这个时候就需要进行多表查询

- 如果我们直接通过查询语句希望在多张表中查询到数据，这个时候是什么效果呢？

  ```mysql
  # 1. 直接从两张表中查询数据
  SELECT * FROM products, brand;
  ```

![image-20230413214527198](assets/image-20230413214527198.png)

## 2. 默认多表查询的结果

- 我们会发现一共有648条数据，这个数据量是如何得到的呢？

  - 第一张表的108条 * 第二张表的6条数据
  - 也就是说第一张表中每一个条数据，都会和第二张表中的每一条数据结合一次
  - 这个结果我们称之为**笛卡尔乘积**，也称之为**直积**，表示为 `X*Y`

- 但是事实上很多的数据是没有意义的，比如华为和苹果、小米的品牌结合起来的数据就是没有意义的，我们可不可以进行筛选呢？

  - 使用 `where` 来进行筛选

  - 这个表示查询到笛卡尔乘积后的结果中，符合 `products.brand_id = brand.id` 条件的数据过滤出来

    ```mysql
    # 2. 从两张表查询所有的数据，再对结果进行过滤（了解，实际开发中不会这样用）
    SELECT * FROM products, brand WHERE products.brand_id = brand.id;
    ```





# 四. 表和表间的连接方式	

---

## 1. 多表之间的连接

- 事实上我们想要的效果并不是这样的，而且表中的某些特定的数据，这个时候我们可以使用 `SQL JOIN` 操作：

  - 左连接、右连接、内连接、全连接

    <img src="assets/image-20230413215349653.png" alt="image-20230413215349653" style="zoom:80%;" />

## 2. 左连接

- 如果我们希望获取到的是左边所有的数据（以左表为主）：

  - 这个时候就表示无论左边的表是否有对应的 `brand_id` 的值对应右边表的 `id`，左边的数据都会被查询出来

  - 这个也是开发中使用最多的情况，它的完整写法是 `LEFT [OUTER] JOIN`，但是 `OUTER` 可以省略的

    <img src="assets/image-20230413215636220.png" alt="image-20230413215636220" style="zoom:80%;" /><img src="assets/image-20230413215654433.png" alt="image-20230413215654433" style="zoom:80%;" />

  - 



# 五. 多对多关系的关系表

---









# 六. 多对多数据查询语句

---









