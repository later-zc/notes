# 一. 面向对象特征一：封装性

---

## 01. 为什么需要封装？

- 我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？
- 我要开车，我不需要懂离合、油门、制动等原理和维修也可以驾驶。
- 客观世界里每一个事物的内部信息都隐藏在其内部，外界无法直接操作和修改，只能通过指定的方式进行访问和修改。

随着我们系统越来越复杂，类会越来越多，那么类之间的访问边界必须把握好，面向对象的开发原则要遵循“ 高内聚、低耦合 ”。

> 高内聚、低耦合是软件工程中的概念，也是UNIX 操作系统设计的经典原则。
>
> 内聚，指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。

而“高内聚，低耦合”的体现之一：

- 高内聚：类的内部数据操作细节自己完成，不允许外部干涉。
- 低耦合：仅暴露少量的方法给外部使用，尽量方便外部调用。

## 02. 何为封装性？

所谓封装，就是把客观事物封装成抽象概念的类，并且类可以把自己的数据和方法只向可信的类或者对象开放，向没必要开放的类或者对象隐藏信息。

**通俗的讲，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。**

## 03. Java如何实现数据封装

- 实现封装就是控制类或成员的可见性范围。这就需要依赖访问控制修饰符，也称为权限修饰符来控制。

- 权限修饰符： public 、 protected 、 缺省 、 private 。具体访问范围如下：

  | 修饰符    | 本类内部 | 本包内 | 其他包的子类 | 其他包非子类 |
  | --------- | -------- | ------ | ------------ | ------------ |
  | private   | 允许     | 不允许 | 不允许       | 不允许       |
  | 缺省      | 允许     | 允许   | 不允许       | 不允许       |
  | protected | 允许     | 允许   | 允许         | 不允许       |
  | public    | 允许     | 允许   | 允许         | 允许         |

  - 具体修饰的结构：
    - 类：只能使用public、缺省
    - 成员变量、成员方法、构造器、成员内部类：public、protected、缺省、private

  <img src="assets/image-20240723003052733.png" alt="image-20240723003052733" style="zoom:80%;" />

## 04. 封装性的体现

1.  成员变量/属性私有化

   概述：**私有化类的成员变量，提供公共的get和set方法，对外暴露获取和修改属性的功能**。

   实现步骤：

   - 使用private修饰成员变量

     ```java
     private 数据类型 变量名;
     ```

     代码如下：

     ```java
     public class Person {
       private String name;
       private int age;
       private boolean marry;
     }
     ```


   - 提供 getXxx 方法 / setXxx 方法，可以访问成员变量，代码如下：

     ```java
     public class Person {
       private String name;
       private int age;
       private boolean marry;
     
       public void setName(String n) {
         name = n;
       }
       public String getName() {
         return name;
       }
       public void setAge(int a) {
         age = a;
       }
       public int getAge() {
         return age;
       }
       public void setMarry(boolean m){
         marry = m;
       }
       public boolean isMarry(){
         return marry;
       }
     }
     ```

   - 测试：

     ```java
     public class PersonTest {
       public static void main(String[] args) {
         Person p = new Person();
         // 实例变量私有化，跨类是无法直接使用的
         /* 
         	p.name = "张三";
         	p.age = 23;
         	p.marry = true;
         */
         p.setName("张三");
         System.out.println("p.name = " + p.getName());
         p.setAge(23);
         System.out.println("p.age = " + p.getAge());
         p.setMarry(true);
         System.out.println("p.marry = " + p.isMarry());
       }
     }
     ```

   - **成员变量封装的好处：**
     - 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里面加入控制逻辑，限制对成员变量的不合理访问。还可以进行数据检查，从而有利于保证对象信息的完整性。
     - 便于修改，提高代码的可维护性。主要说的是隐藏的部分，在内部修改了，如果其对外可以的访问方式不变的话，外部根本感觉不到它的修改。例如：Java8=>Java9，String从char[]转为byte[]内部实现，而对外的方法不变，我们使用者根本感觉不到它内部的修改。

2.  私有化方法

    ```java
    // 自定义的操作数组的工具类
    public class ArrayUtil {
      // 求int型数组的最大值
      public int max(int[] arr) {
        int maxValue = arr[0];
        for(int i = 1;i < arr.length;i++){
          if(maxValue < arr[i]){
            maxValue = arr[i];
          }
        }
        return maxValue;
      }
      // 求int型数组的最小值
      public int min(int[] arr){
        int minValue = arr[0];
        for(int i = 1;i < arr.length;i++){
          if(minValue > arr[i]){
            minValue = arr[i];
          }
        }
        return minValue;
      }
      // 求int型数组的总和
      public int sum(int[] arr) {
        int sum = 0;
        for(int i = 0;i < arr.length;i++){
          sum += arr[i];
        }
        return sum;
      }
      // 求int型数组的元素的平均值
      public int avg(int[] arr) {
        int sumValue = sum(arr);
        return sumValue / arr.length;
      }
      // 创建一系列重载的上述方法
      // public double max(double[] arr){}
      // public float max(float[] arr){}
      // public byte max(byte[] arr){}
    
      // 遍历数组
      public void print(int[] arr) {
        for(int i = 0;i < arr.length;i++){
          System.out.print(arr[i] + " ");
        }
        System.out.println();
      }
      // 复制数组arr
      public int[] copy(int[] arr) {
        int[] arr1 = new int[arr.length];
        for(int i = 0;i < arr.length;i++){
          arr1[i] = arr[i];
        }
        return arr1;
      }
      // 反转数组
      public void reverse(int[] arr) {
        for(int i = 0,j = arr.length - 1;i < j;i++,j--){
          int temp = arr[i];
          arr[i] = arr[j];
          arr[j] = temp;
        }
      }
      /**
      *
      * @Description 数组的排序
      * @param arr
      * @param desc 指明排序的方式。 ascend:升序 descend:降序
      */
      public void sort(int[] arr,String desc) {
        if ("ascend".equals(desc)) {
          for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) 				{
              if (arr[j] > arr[j + 1]) {
                swap(arr,j,j+1);
              }
            }
          }
        }
        else if ("descend".equals(desc)) {
          for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++){
              if (arr[j] < arr[j + 1]) {
                swap(arr,j,j+1);
              }
            }
          }
        }else{
          System.out.println("您输入的排序方式有误！");
        }
      }
      private void swap(int[] arr,int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
      
      /**
      * @Description 查找指定的value值在arr数组中出现的位置
      * @param arr
      * @param value
      * @return 返回value值出现的位置 或 -1：未找到
      */
      public int getValue(int[] arr, int value) {
        //方法：线性查找
        for(int i = 0;i < arr.length;i++){
          if(value == arr[i]){
            return i;
          }
        }
        return - 1;
      }
    }
    ```

> 注意：
>
> - 开发中，一般成员实例变量都习惯使用private修饰，再提供相应的public权限的get/set方法访问。
> - 对于final的实例变量，不提供set()方法。（后面final关键字的时候讲）
> - 对于static final的成员变量，习惯上使用public修饰。

## 05. 练习

1. 创建程序：在其中定义两个类：Person和PersonTest类。定义如下：用setAge()设置人的合法年龄(0~130)，用getAge()返回人的年龄。在PersonTest类中实例化Person类的对象b，调用setAge()和getAge()方法，体会Java的封装性。

   <img src="assets/image-20240724234858518.png" alt="image-20240724234858518" style="zoom:80%;" />

2. 自定义图书类。设定属性包括：书名bookName，作者author，出版社名publisher，价格price；方法包括：相应属性的get/set方法，图书信息介绍等。





# 二. 类的成员之三：构造器constructor

---

我们new完对象时，所有成员变量都是默认值，如果我们需要赋别的值，需要挨个为它们再赋值，太麻烦了。我们能不能在new对象时，直接为当前对象的某个或所有成员变量直接赋值呢？

可以，Java给我们提供了 构造器（Constructor) ，也称为 构造方法 。

## 01. 构造器的作用

new对象，并在new对象的时候为实例变量赋值。

举例：Person p = new Person(“Peter”,15) ;

解释：如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。

## 02. 构造器的语法格式

```java
[修饰符] class 类名{
  [修饰符] 构造器名(){
    // 实例初始化代码
  }
  [修饰符] 构造器名(参数列表){
    // 实例初始化代码
  }
}
```

说明：

1.  构造器名必须与它所在的类名必须相同。
2. 它没有返回值，所以不需要返回值类型，也不需要void。
3. 构造器的修饰符只能是权限修饰符，不能被其他任何修饰。比如，不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值。

代码如下：

```java
public class Student {
  private String name;
  private int age;
  // 无参构造
  public Student() {}
  // 有参构造
  public Student(String n,int a) {
    name = n;
    age = a;
  }
  public String getName() {
    return name;
  }
  public void setName(String n) {
    name = n;
  }
  public int getAge() {
    return age;
  }
  public void setAge(int a) {
    age = a;
  }
  public String getInfo(){
    return "姓名：" + name +"，年龄：" + age;
  }
}
```







